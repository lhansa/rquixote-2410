---
title: "Este es el ecosistema R que uso en el trabajo"
subtitle: "Herramientas del mundo R que uso, que debería usar mejor y que no uso pero me gustaría"
author: "Leonardo Hansa"
date: 10/03/2024
date-format: "D/M/YYYY"
format: 
  revealjs: 
    theme: 
      - simple
      - custom.scss
    logo: img/LogoLH.png
    transition: slide
    toc: true
    toc-depth: 1
    toc-title: "Qué te voy a contar"
execute: 
  eval: false
  echo: true
---


# Una historia antes {.unnumbered .unlisted}

```{r}
#| label: libs
#| eval: true
#| echo: false
library(ggplot2)
library(dplyr)
library(tidyr)

theme_set(theme_bw())

```

# Contexto

## Si inviertes 10 millones en publicidad, ¿de qué te sirve?

- Empresa _A_ invierte dinero en publicidad. 
    - Controla a ojo si las ventas suben o bajan un poco después. 
- Empresa _A_ quiere saber **cuántas** ventas ha conseguido gracias a la publicidad.
- Ebiquity le da una aproximación que obtiene con modelos estadísticos.

## Observación: esta charla no va de econometría

Lo que voy a hacer es contarte el papel de R en ese tipo de proyectos que hacemos.

## ¿Quién hace los modelos? El consultor _B_

- El consultor _B_ sabe estadística
- El consultor _B_ sabe de publi
- El consultor _B_ sabe Excel
- El consultor _B_ puede saber programar

Pero no se dedica a automatizar tareas ni a procesar ficheros complejos.

## De eso a lo que no se dedica el consultor _B_ es de lo que te voy a hablar

## Las técnicas estadísticas son casi siempre las mismas de proyecto a proyecto

- Modelos con datos de panel
- Bayesianos
- Con coeficientes dinámicos
- Búsqueda de hiperparámetros
- Transformaciones de variables

## Las tareas repetitivas se desarrollan con herramientas internas

El ecosistema de estas herramientas es lo que te voy a contar ahora.

# Planteamiento del ecosistema

## Los consultores usan Excel

![XSec - Una plantilla en Excel](img/xsec.PNG)

## En Excel especifican todo lo que R necesita saber {.smaller}

| Variable                                                                                                      | CrossSection | Decomp Interval |  Decomp Group  |
|---------------------------------------------------------------------------------------------------------------|:------------:|:---------------:|:--------------:|
| INTERCEPT                                                                                                     | CrossSection |        10       |     1.Base     |
| log(cci)-log(min(cci,na.rm=TRUE))                                                                             | SystemNumber |        4        |    2.Market    |
| gmpc_giveaway_alt                                                                                             | CrossSection |        1        |     3.Promo    |
| movav(adstock(dimret(.TV.,160,rescale=FALSE),0.3,normalize=TRUE),1)                                           | CrossSection |        1        |      4.TV      |
| adstock(dimret(m_drms_vd_spnd,10000,rescale=FALSE),0.3,normalize=TRUE)                                        |    Region    |        1        |      4.TV      |
| adstock(dimret(m_drms_tvspnsrshp_tvrs,170,rescale=FALSE),0.3,normalize=TRUE)                                  |    Region    |        1        |      4.TV      |
| adstock(m_drms_rd_spnd,0.3)                                                                                   |    Region    |        1        |     5.Radio    |
| adstock(m_drms_oh_spnd,0.8)                                                                                   | SystemNumber |        1        |  6.Other Media |
| adstock(.Bensons_TV.,0.7,normalize=TRUE)                                                                      | CrossSection |        1        |     1.Base     |
| lag(bh_xmas, 1)                                                                                               | CrossSection |        10       |    2.Market    |
| bh_xmas                                                                                                       | CrossSection |        10       |    2.Market    |
| (OBS ==   "2015-12-14")                                                                                       | CrossSection |        10       |     1.Base     |
| ...                                                                                                           |      ...     |       ...       |       ...      |


## Excel usa Visual Basic

```{verbatim}
RScriptLoc = """" & gwsRSpec.Range("location_RProg").Value & "\library\ebcore\estimate_model.R"""

cmdline = """" & RLocation & """" & " " & RScriptLoc & " """ & workdir & """ """ & "" & """ """ & xsec_version & "" & """ """ & bayes_model & "" & """ """ & API_KEY & "" & """ """ & API_SECRET & """"

shellAndWait cmdline, True
```

## ¿Conoces `Rscript` y commandArgs()`?

```{r}
#| label: command-args
#| eval: false
message("Esto contiene el objeto commandArgs():")
commandArgs()

message("Y puedo utilizar sus elementos:")
toupper(commandArgs()[6])
```

## `Rscript` lo usas desde línea de comandos

```{bash}
$ Rscript.exe ejemplo-commands.R "mensaje para editar"
```

```{verbatim}
Esto contiene el objeto commandArgs():
[1] "C:/Program Files/R/R-4.4.1/bin/x64/Rterm.exe"
[2] "--no-echo"
[3] "--no-restore"
[4] "--file=ejemplo-commands.R"
[5] "--args"
[6] "mensaje para editar"
Y puedo utilizar sus elementos:
[1] "MENSAJE PARA EDITAR"
```


## Nuestro ecosistema consiste en varias librerías de R a las que Excel llama para cada tarea


# Quién soy yo

# `ebverse`

## Los proyectos de modelización giran en torno a la _Cross Sectional Tool..._

![XSec - Una plantilla en Excel](img/xsec.PNG)

## ..que necesita de R para funcionar

```{r}
#| label: ebcore-run-model
remove(list = ls())
necessary_packages <- c(
  "aws.s3",
  "data.table",
  "devtools",
  "dplyr",
  "remotes",
  "stringr",
  "tidyr"
)
for (package in necessary_packages) {
  if (length(find.package(package, quiet = TRUE)) == 0) {
    install.packages(
      package,
      lib = .Library,
      repos = "https://cloud.r-project.org"
    )
  }
}

suppressPackageStartupMessages(library(dplyr))


xsec_version <- commandArgs()[8]
if (!is.na(xsec_version)) {
  xsec_version <- numeric_version(xsec_version)
}


packageStartupMessage("==============================================================")
## Logo -----------------------------------------------
packageStartupMessage("
 _       _   ______   _______   _______
  |_   _|   |        |         |
    |_|     |_____   |_______  |
   _| |_          |  |         |
 _|     |_  ______|  |_______  |_______
  ")
if (length(find.package("XSEXCELR", quiet = TRUE)) != 0) {
  packageStartupMessage(paste0("Package ", "v.", packageVersion("XSEXCELR")))
}

packageStartupMessage(paste0("Template ", "v.", xsec_version))
packageStartupMessage("==============================================================")



## Check package versions -----------------------------------------------
writeLines("\nChecking Package Versions ...")

tryCatch(
  {
    ebcore::update_packages(xsec_version)
  },
  error = function(e) {}
)

## Load packages and options ---------------------------------------
suppressPackageStartupMessages(library(eble, quietly = TRUE))
suppressPackageStartupMessages(library(dplyr, quietly = TRUE))
suppressWarnings(suppressPackageStartupMessages(library(XSEXCELR)))
suppressPackageStartupMessages(library(methods, quietly = TRUE))
suppressPackageStartupMessages(library(lubridate, quietly = TRUE))

options(
  error = XSEXCELR:::xsec_error_function,
  verbose_xsec = TRUE,
  datatable.old.fread.datetime.character = TRUE
)





## Get name of working directory --------------------------------------------
spec_dir <- XSEXCELR:::get_spec_dir(cmdarg = commandArgs())
decomp_choice <- commandArgs()[7]
bayes_model <- commandArgs()[9]
access_key <- commandArgs()[10]
secret_access_key <- commandArgs()[11]
if (decomp_choice == "" || is.na(decomp_choice)) {
  decomp_choice <- NA
}

## Log warnings---------------------------------------------------------------
warning_file <- file(sprintf("%s/RScriptErrors.log", spec_dir), open = "wt")

sink(warning_file, type = "message")

if (file.exists(sprintf("%s/Done.csv", spec_dir)) && interactive()) {
  # Normally deleted by xsec tool to signal when it's safe to save output
  file.remove(sprintf("%s/Done.csv", spec_dir))
}


if (is.na(bayes_model)) {
  bayes_model <- FALSE
} else if (bayes_model == "True") {
  bayes_model <- TRUE
} else {
  bayes_model <- FALSE
}


if (!is.na(decomp_choice)) {
  run_decomp <- TRUE
} else {
  run_decomp <- FALSE
}

## Estimate model using spec stored in spec_dir -----------------------------
if (bayes_model) {
  aws_credentials(access_key, secret_access_key)
  MODEL <- bayes_estimate(
    spec_dir = spec_dir,
    save_flag = TRUE,
    log = FALSE
  )
} else {
  MODEL <- XSEXCELR:::wextimate_decomp(
    spec_dir = spec_dir,
    save_flag = TRUE,
    decomp_choice = "",
    run_decomp = run_decomp
  )
}



### Run custom script
spec2 <- XSEXCELR:::.importDecompChoice(spec_dir = spec_dir)

# Check if there is a "Custom Script" setting in the spec2 data frame
if (any(spec2$Setting == "Custom Script")) {
  # Retrieve the script location specified under "Custom Script"
  script_loc <- spec2$Value[spec2$Setting == "Custom Script"]

  # Validate that the script location is not NA and is a non-empty string
  if (!is.na(script_loc) && nzchar(script_loc)) {
    # Split the script location into the file path and any arguments
    script_parts <- trimws(strsplit(script_loc, "--")[[1]])
    script_path <- normalizePath(script_parts[1])

    # Combine arguments if they exist
    script_args <- if (length(script_parts) > 1) {
      paste(shQuote(script_parts[-1]), collapse = " ")
    } else {
      ""
    }

    # Check if the script file exists at the specified path
    if (file.exists(script_path)) {
      writeLines("Running Custom R-Script...")

      # Construct the command to run the R script with arguments
      r_executable <- normalizePath(file.path(R.home("bin"), "Rscript.exe"))
      cmd <- paste(shQuote(r_executable), shQuote(script_path), script_args)

      # Execute the command
      system(cmd)
    } else {
      stop("The specified Custom R script could not be found. If you are using custom arguments, please separate them with two hyphens, i.e. myScript.R --Arg1 --Arg2.")
    }
  }
}


## End message --------------------------------------------------------------
XSEXCELR:::xsec_end_message()
```

## La herramienta transforma variables a partir de la sintaxis R que el usuario ha escrito

```{r}
#| label: multiple-trans
movav(adstock(dim_ret(tv_region1,160,rescale=FALSE),0.3,normalize=TRUE))
```

## Los rendimientos decrecientes son una transformación frecuente en publicidad...

$$
x' = \frac{x}{x + b}
$$

- $x$ es la variable explicativa original
- $b\in \mathbb{R}$ es un parámetro que hay que estimar

## ...que visualmente se traducen en esto

```{r}
#| label: sim-dimret
#| echo: false
#| eval: true

set.seed(114)
nobs <- 200
fechas_con_publi <- 75
asymt <- 4
b1 <- 60
intercept <- 100


data <- data.frame(
  fecha = 1:nobs,
  ruido = rnorm(nobs, 0, 1),
  x = numeric(nobs)
)

data$x[sample(1:nobs, fechas_con_publi, replace = FALSE)] <- 
  rlnorm(fechas_con_publi)

data$xd <- data$x / (data$x + asymt)
data$y <- intercept + b1 * data$xd + data$ruido

mod_dimret <- lm(y ~ xd, data = data)
mod_lineal <- lm(y ~ x, data = data)

data$aportes_lineales <- mod_lineal$coefficients["x"] * data$x
data$aportes_dimret <- mod_dimret$coefficients["xd"] * data$xd

ggplot(data) + 
  geom_point(
    aes(x = x, y = aportes_lineales), 
    shape = 21, col = "#800080", fill = "yellow", size = 2
    ) + 
  geom_point(
    aes(x = x, y = aportes_dimret), 
    col = "#800080", size = 2
  ) + 
  labs(x = "Inversión", y = "Contribución" ,
       title = "Comportamiento de los rendimientos decrecientes")

```

## En una de nuestras librerías tenemos transformaciones como estas a mano

```{r}
#| label: dim-ret
#| echo: true
#| eval: true
eble::dim_ret
```

## El efecto ad-stock simula el recuerdo publicitario

```{r}
#| label: sim-adstock
#| eval: true
#| echo: false

efectos <- c(0.2, 0.4, 0.8)

l_adstocks <- lapply(efectos, function(ads) {
  eble::adstock(data$xd, p = ads)  
})

new_cols <- paste0("xd_ads", as.character(efectos * 100))

data[, new_cols] <- l_adstocks 

data |> 
  select(fecha, starts_with("xd")) |> 
  pivot_longer(-fecha) |> 
  ggplot() + 
  geom_line(aes(x = fecha, y = value), linewidth = 1, col = "#800080") + 
  facet_grid(name ~ .) + 
  labs(
    x = "Tiempo", y = "Métrica", 
    title = "El efecto ad-stock extiende el valor de la métrica hacia adelante", 
    subtitle = "La idea es simular un recuerdo"
  )
```

## Para este efecto también tenemos función en la librería eble

```{r}
#| label: adstock
#| echo: true
#| eval: true

eble::adstock
```

## Otra librería tiene wrappers de funciones más típicas

```{r}
#| label: safe-left-join
#| echo: true
#| eval: true

ebility::safe_left_join
```

## Súper cómodo para intercambiar R y Excel

```{r}
#| label: clipboard
#| echo: true
#| eval: true

ebility::clipboard
```



## Librerías en ebverse {.smaller}

- **eble**
- **ebility**
- **XSEXCELR.** Algoritmos de modelización.
- **debcomp.** Cálculo de contribuciones en modelos multiplicativos.
- **ebjobs.** Automatización de procesos de la herramienta de modelización.
- **ebcore.** Operaciones tuneadas de R.
- **ebdb.** Lectura de datos de distintas fuentes.
- **mediaconsolidator.** Procesamiento de datos de inversión en publicidad.
- **roicalculator.** Cómputo de retorno de la inversión publicitaria, a partir de las contribuciones de los modelos de **XSEXCELR** y **debcomp** y de lo procesado por **mediaconsolidator**.


## Unos comentarios

::: {.incremental}

- Casi todas las librerías las usamos como backends de las interfaces en Excel
- Algunas como **eble** las usamos para procesamiento de datos directamente con código
  + Pero pocas
  
:::

## Qué hacemos mal

- Tests 
- Git / GitHub

## Hacemos muy pocos tests

![](img/tests-rodolfo.PNG)

## En un test realizas operaciones cuyo resultado conoces

Cada vez que editas tu librería, ejecutas todos los tests para garantizar que lo nuevo no rompe lo que ya funcionaba

```{r}
#| label: ejemplo-test
# Load the testthat package and the package that contains the function
library(testthat)
library(rodolfo)

# Create a test block
test_that("apply_adstock works correctly", {


  # Test the output of the function with the example data
  m_adstock <- apply_adstock(loaded_excel_test,
                             c(target_name, variables_in_model))


  expect_type(m_adstock, "double")
  expect_equal(ncol(m_adstock), length(variables_in_model)+1)

  expect_equal(m_adstock, m_adstock_test)


})
```


## Alojamos todo en GitHub, pero nos cuesta seguir nuestras propias pautas {.smaller}

![](img/pull-request.PNG)


# Shiny

## Nos da pereza infinita meter cambios en las plantillas de Excel. 

Shiny es nuestra herramienta para ampliar funcionalidades

## Excel carga las Shiny Apps con lo que hemos visto sobre `Rscript.exe`

<!-- TODO Código de carga de un shiny app-->
 

## Shiny apps como librerías de R

Todas nuestras apps siguen el marco _golem_ (**más o menos**).

```{r}
#| label: result-explorer-schema
#| echo: false
#| eval: true
fs::dir_tree("C:/Users/Leonardo.Hansa/Documents/tools/rosalind")
```


## Qué hacemos mal

- renv
- módulos (resultsexplorer)


# Qué echo en falta

## Quarto
